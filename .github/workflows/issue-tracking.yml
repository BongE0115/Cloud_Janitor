name: Project status check and update referencing tasks

on:
  issues:
    types: [closed, reopened, edited]

permissions:
  contents: read
  issues: write
  repository-projects: write

jobs:
  sync:
    runs-on: ubuntu-latest
    env:
      STATUS_FIELD_NAME: "Status"
      DONE_OPTION_NAME: "Done"
      REOPEN_OPTION_NAME: "In Progress"
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const issue = context.payload.issue;
            const number = issue.number;
            const action = context.payload.action;
            const isClosed = action === 'closed';
            const isReopened = action === 'reopened';

            // Checklist helpers
            const taskLine = /^\s*[-*+]\s\[( |x|X)\]\s.+$/;
            const isChecked = (line) => /\[[xX]\]/.test(line);

            // If edited, auto-close this issue if all tasks are checked
            if (action === 'edited') {
              const bodyText = issue.body || '';
              const selfLines = bodyText.split(/\r?\n/);
              const selfTasks = selfLines.filter(l => taskLine.test(l));
              const selfHasTasks = selfTasks.length > 0;
              const selfAllChecked = selfHasTasks && selfTasks.every(isChecked);
              if (selfHasTasks && selfAllChecked && issue.state !== 'closed') {
                await github.rest.issues.update({ owner, repo, issue_number: number, state: 'closed' });
                core.info(`Auto-closed #${number} after edit (all tasks complete)`);
              }
            }

            // Helper function to update parent issues recursively
            async function updateParentIssues(targetIssueNumber, shouldCheck) {
              const esc = s => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
              const uncheckedTask = /^(\s*-\s\[)\s(\]\s.*)$/;
              const checkedTask   = /^(\s*-\s\[)[xX](\]\s.*)$/;
              
              // Find issues that reference this issue
              // For close: search open issues only (to check and close them)
              // For reopen: search ALL issues including closed (to uncheck and reopen them)
              const stateFilter = shouldCheck ? 'is:open' : 'is:issue';
              const qBase = `repo:${owner}/${repo} ${stateFilter} in:body`;
              const issueUrl = `https://github.com/${owner}/${repo}/issues/${targetIssueNumber}`;
              const q = `${qBase} "#${targetIssueNumber}" OR ${qBase} "${issueUrl}"`;
              
              const searchRes = await github.rest.search.issuesAndPullRequests({ q, per_page: 50 });
              const refRegex = new RegExp(`(?:#${targetIssueNumber}\\b|${esc(issueUrl)})`, 'i');
              
              const affectedParents = [];
              
              for (const item of searchRes.data.items) {
                if (item.pull_request) continue;
                const parentNumber = item.number;
                const body = item.body || '';
                const lines = body.split(/\r?\n/);
                let changed = false;

                for (let i = 0; i < lines.length; i++) {
                  const line = lines[i];
                  if (!refRegex.test(line)) continue;

                  if (shouldCheck && uncheckedTask.test(line)) {
                    // Check the checkbox: [ ] -> [x]
                    lines[i] = line.replace(uncheckedTask, '$1x$2');
                    changed = true;
                  } else if (!shouldCheck && checkedTask.test(line)) {
                    // Uncheck the checkbox: [x] -> [ ]
                    lines[i] = line.replace(checkedTask, '$1 $2');
                    changed = true;
                  }
                }

                if (changed) {
                  await github.rest.issues.update({
                    owner, repo, issue_number: parentNumber, body: lines.join('\n'),
                  });
                  core.info(`Updated checklist in #${parentNumber} (ref: #${targetIssueNumber})`);
                }

                // Check if all tasks are now complete in this parent issue
                const effectiveLines = changed ? lines : body.split(/\r?\n/);
                const tasks = effectiveLines.filter(l => taskLine.test(l));
                const hasTasks = tasks.length > 0;
                const allChecked = hasTasks && tasks.every(isChecked);
                
                if (shouldCheck) {
                  // CLOSE case: auto-close if all tasks complete
                  if (hasTasks && allChecked && item.state !== 'closed') {
                    await github.rest.issues.update({ owner, repo, issue_number: parentNumber, state: 'closed' });
                    core.info(`Auto-closed #${parentNumber} (all tasks complete, triggered by #${targetIssueNumber})`);
                    affectedParents.push(parentNumber);
                  }
                } else {
                  // REOPEN case: auto-reopen if a task was unchecked and parent is closed
                  if (changed && item.state === 'closed') {
                    await github.rest.issues.update({ owner, repo, issue_number: parentNumber, state: 'open' });
                    core.info(`Auto-reopened #${parentNumber} (task unchecked, triggered by #${targetIssueNumber})`);
                    affectedParents.push(parentNumber);
                  }
                }
              }
              
              return affectedParents;
            }
            
            // Recursive function to propagate changes up the hierarchy (child → parent)
            async function propagateUpHierarchy(issueNumbers, shouldCheck, depth = 0) {
              const maxDepth = 10; // Prevent infinite loops
              
              if (depth >= maxDepth) {
                core.warning(`Max hierarchy depth (${maxDepth}) reached. Stopping upward propagation.`);
                return;
              }
              
              if (issueNumbers.length === 0) {
                return;
              }
              
              core.info(`⬆️ Propagating UP level ${depth + 1}: processing ${issueNumbers.length} issue(s)`);
              
              const affectedParents = [];
              
              for (const issueNum of issueNumbers) {
                const parents = await updateParentIssues(issueNum, shouldCheck);
                affectedParents.push(...parents);
              }
              
              // Remove duplicates
              const uniqueAffected = [...new Set(affectedParents)];
              
              if (uniqueAffected.length > 0) {
                const actionVerb = shouldCheck ? 'auto-closed' : 'auto-reopened';
                core.info(`⬆️ Level ${depth + 1}: ${uniqueAffected.length} parent issue(s) were ${actionVerb}`);
                // Recursively process the affected parents
                await propagateUpHierarchy(uniqueAffected, shouldCheck, depth + 1);
              }
            }
            
            // Helper function to extract child issue numbers from issue body
            function extractChildIssues(body) {
              const childIssues = [];
              const issueRefRegex = /(?:#(\d+)|https:\/\/github\.com\/[^\/]+\/[^\/]+\/issues\/(\d+))/g;
              
              let match;
              while ((match = issueRefRegex.exec(body)) !== null) {
                const issueNum = parseInt(match[1] || match[2], 10);
                if (!isNaN(issueNum) && !childIssues.includes(issueNum)) {
                  childIssues.push(issueNum);
                }
              }
              
              return childIssues;
            }
            
            // Helper function to update child issues (close/reopen them)
            async function updateChildIssues(parentNumber, shouldClose) {
              // Get the parent issue body
              const { data: parentIssue } = await github.rest.issues.get({
                owner, repo, issue_number: parentNumber
              });
              
              const body = parentIssue.body || '';
              const childNumbers = extractChildIssues(body);
              
              if (childNumbers.length === 0) {
                return [];
              }
              
              const affectedChildren = [];
              const targetState = shouldClose ? 'closed' : 'open';
              const oppositeState = shouldClose ? 'open' : 'closed';
              
              for (const childNum of childNumbers) {
                try {
                  // Get child issue current state
                  const { data: childIssue } = await github.rest.issues.get({
                    owner, repo, issue_number: childNum
                  });
                  
                  // Only update if state needs to change
                  if (childIssue.state === oppositeState) {
                    await github.rest.issues.update({
                      owner, repo, issue_number: childNum, state: targetState
                    });
                    
                    const actionVerb = shouldClose ? 'closed' : 'reopened';
                    core.info(`Auto-${actionVerb} child #${childNum} (triggered by parent #${parentNumber})`);
                    affectedChildren.push(childNum);
                  }
                } catch (e) {
                  // Issue might not exist or be inaccessible
                  core.warning(`Could not update child #${childNum}: ${e.message}`);
                }
              }
              
              return affectedChildren;
            }
            
            // Recursive function to propagate changes down the hierarchy (parent → child)
            async function propagateDownHierarchy(issueNumbers, shouldClose, depth = 0) {
              const maxDepth = 10; // Prevent infinite loops
              
              if (depth >= maxDepth) {
                core.warning(`Max hierarchy depth (${maxDepth}) reached. Stopping downward propagation.`);
                return;
              }
              
              if (issueNumbers.length === 0) {
                return;
              }
              
              core.info(`⬇️ Propagating DOWN level ${depth + 1}: processing ${issueNumbers.length} issue(s)`);
              
              const affectedChildren = [];
              
              for (const issueNum of issueNumbers) {
                const children = await updateChildIssues(issueNum, shouldClose);
                affectedChildren.push(...children);
              }
              
              // Remove duplicates
              const uniqueAffected = [...new Set(affectedChildren)];
              
              if (uniqueAffected.length > 0) {
                const actionVerb = shouldClose ? 'auto-closed' : 'auto-reopened';
                core.info(`⬇️ Level ${depth + 1}: ${uniqueAffected.length} child issue(s) were ${actionVerb}`);
                // Recursively process the affected children
                await propagateDownHierarchy(uniqueAffected, shouldClose, depth + 1);
              }
            }

            // Start the recursive update from the current issue
            if (isClosed || isReopened) {
              const shouldCheck = isClosed;
              core.info(`Starting bidirectional hierarchical update for #${number} (${isClosed ? 'closed' : 'reopened'})`);
              
              // Propagate UP: update parent issues
              await propagateUpHierarchy([number], shouldCheck, 0);
              
              // Propagate DOWN: update child issues
              await propagateDownHierarchy([number], shouldCheck, 0);
            }

            // Only proceed to project status updates on close/reopen
            if (!(isClosed || isReopened)) {
              return;
            }

            // 2) Update project status of referenced issues
            const statusFieldName = process.env.STATUS_FIELD_NAME || 'Status';
            const doneOptionName = process.env.DONE_OPTION_NAME || 'Done';
            const reopenOptionName = process.env.REOPEN_OPTION_NAME || 'In Progress';
            const desiredOptionName = isClosed ? doneOptionName : reopenOptionName;

            const data = await github.graphql(`
              query($owner: String!, $repo: String!, $number: Int!) {
                repository(owner: $owner, name: $repo) {
                  issue(number: $number) {
                    id
                    projectItems(first: 50) {
                      nodes {
                        id
                        project {
                          ... on ProjectV2 { id title }
                        }
                      }
                    }
                  }
                }
              }
            `, { owner, repo, number });

            const items = data?.repository?.issue?.projectItems?.nodes || [];
            if (items.length === 0) {
              core.info('No project items to update.');
              return;
            }

            const itemsByProject = items.reduce((acc, it) => {
              const projectId = it.project?.id;
              if (!projectId) return acc;
              acc[projectId] = acc[projectId] || [];
              acc[projectId].push(it.id);
              return acc;
            }, {});

            for (const [projectId, itemIds] of Object.entries(itemsByProject)) {
              const proj = await github.graphql(`
                query($id: ID!) {
                  node(id: $id) {
                    ... on ProjectV2 {
                      id
                      title
                      fields(first: 50) {
                        nodes {
                          ... on ProjectV2SingleSelectField {
                            id
                            name
                            options { id name }
                          }
                        }
                      }
                    }
                  }
                }
              `, { id: projectId });

              const fields = proj?.node?.fields?.nodes || [];
              const statusField = fields.find(f => f?.name?.toLowerCase() === statusFieldName.toLowerCase());
              if (!statusField) {
                core.info(`Project ${proj?.node?.title || projectId} has no field "${statusFieldName}". Skipping.`);
                continue;
              }
              const option = statusField.options.find(o => o?.name?.toLowerCase() === desiredOptionName.toLowerCase());
              if (!option) {
                core.info(`Project ${proj?.node?.title || projectId} field "${statusFieldName}" has no option "${desiredOptionName}". Skipping.`);
                continue;
              }

              for (const itemId of itemIds) {
                try {
                  await github.graphql(`
                    mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: ID!) {
                      updateProjectV2ItemFieldValue(input: {
                        projectId: $projectId,
                        itemId: $itemId,
                        fieldId: $fieldId,
                        value: { singleSelectOptionId: $optionId }
                      }) {
                        clientMutationId
                      }
                    }
                  `, {
                    projectId,
                    itemId,
                    fieldId: statusField.id,
                    optionId: option.id,
                  });
                  core.info(`Updated project item ${itemId} -> ${desiredOptionName}`);
                } catch (e) {
                  core.warning(`Failed updating item ${itemId}: ${e.message}`);
                }
              }
            }
