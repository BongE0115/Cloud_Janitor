name: Project status check and update referencing tasks

on:
  issues:
    types: [closed, reopened, edited]

permissions:
  contents: read
  issues: write
  repository-projects: write

jobs:
  sync:
    runs-on: ubuntu-latest
    env:
      STATUS_FIELD_NAME: "Status"
      DONE_OPTION_NAME: "Done"
      REOPEN_OPTION_NAME: "In Progress"
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const issue = context.payload.issue;
            const number = issue.number;
            const action = context.payload.action;
            const isClosed = action === 'closed';
            const isReopened = action === 'reopened';

            // Checklist helpers
            const taskLine = /^\s*[-*+]\s\[( |x|X)\]\s.+$/;
            const isChecked = (line) => /\[[xX]\]/.test(line);

            // If edited, auto-close this issue if all tasks are checked
            if (action === 'edited') {
              const bodyText = issue.body || '';
              const selfLines = bodyText.split(/\r?\n/);
              const selfTasks = selfLines.filter(l => taskLine.test(l));
              const selfHasTasks = selfTasks.length > 0;
              const selfAllChecked = selfHasTasks && selfTasks.every(isChecked);
              if (selfHasTasks && selfAllChecked && issue.state !== 'closed') {
                await github.rest.issues.update({ owner, repo, issue_number: number, state: 'closed' });
                core.info(`Auto-closed #${number} after edit (all tasks complete)`);
              }
            }

            // Helper function to update parent issues recursively
            async function updateParentIssues(closedIssueNumber, shouldCheck) {
              const esc = s => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
              const uncheckedTask = /^(\s*-\s\[)\s(\]\s.*)$/;
              const checkedTask   = /^(\s*-\s\[)[xX](\]\s.*)$/;
              
              // Find issues that reference this issue
              const qBase = `repo:${owner}/${repo} is:issue is:open in:body`;
              const issueUrl = `https://github.com/${owner}/${repo}/issues/${closedIssueNumber}`;
              const q = `${qBase} "#${closedIssueNumber}" OR ${qBase} "${issueUrl}"`;
              
              const searchRes = await github.rest.search.issuesAndPullRequests({ q, per_page: 50 });
              const refRegex = new RegExp(`(?:#${closedIssueNumber}\\b|${esc(issueUrl)})`, 'i');
              
              const closedParents = [];
              
              for (const item of searchRes.data.items) {
                if (item.pull_request) continue;
                const parentNumber = item.number;
                const body = item.body || '';
                const lines = body.split(/\r?\n/);
                let changed = false;

                for (let i = 0; i < lines.length; i++) {
                  const line = lines[i];
                  if (!refRegex.test(line)) continue;

                  if (shouldCheck && uncheckedTask.test(line)) {
                    // Check the checkbox: [ ] -> [x]
                    lines[i] = line.replace(uncheckedTask, '$1x$2');
                    changed = true;
                  } else if (!shouldCheck && checkedTask.test(line)) {
                    // Uncheck the checkbox: [x] -> [ ]
                    lines[i] = line.replace(checkedTask, '$1 $2');
                    changed = true;
                  }
                }

                if (changed) {
                  await github.rest.issues.update({
                    owner, repo, issue_number: parentNumber, body: lines.join('\n'),
                  });
                  core.info(`Updated checklist in #${parentNumber} (ref: #${closedIssueNumber})`);
                }

                // Check if all tasks are now complete in this parent issue
                const effectiveLines = changed ? lines : body.split(/\r?\n/);
                const tasks = effectiveLines.filter(l => taskLine.test(l));
                const hasTasks = tasks.length > 0;
                const allChecked = hasTasks && tasks.every(isChecked);
                
                if (shouldCheck && hasTasks && allChecked && item.state !== 'closed') {
                  await github.rest.issues.update({ owner, repo, issue_number: parentNumber, state: 'closed' });
                  core.info(`Auto-closed #${parentNumber} (all tasks complete, triggered by #${closedIssueNumber})`);
                  closedParents.push(parentNumber);
                }
              }
              
              return closedParents;
            }
            
            // Recursive function to propagate changes up the hierarchy
            async function propagateUpHierarchy(issueNumbers, shouldCheck, depth = 0) {
              const maxDepth = 10; // Prevent infinite loops
              
              if (depth >= maxDepth) {
                core.warning(`Max hierarchy depth (${maxDepth}) reached. Stopping propagation.`);
                return;
              }
              
              if (issueNumbers.length === 0) {
                return;
              }
              
              core.info(`Propagating level ${depth + 1}: processing ${issueNumbers.length} issue(s)`);
              
              const newlyClosed = [];
              
              for (const issueNum of issueNumbers) {
                const closedParents = await updateParentIssues(issueNum, shouldCheck);
                newlyClosed.push(...closedParents);
              }
              
              // Remove duplicates
              const uniqueNewlyClosed = [...new Set(newlyClosed)];
              
              if (uniqueNewlyClosed.length > 0) {
                core.info(`Level ${depth + 1}: ${uniqueNewlyClosed.length} parent issue(s) were auto-closed`);
                // Recursively process the newly closed parents
                await propagateUpHierarchy(uniqueNewlyClosed, shouldCheck, depth + 1);
              }
            }

            // Start the recursive update from the current issue
            if (isClosed || isReopened) {
              const shouldCheck = isClosed;
              core.info(`Starting hierarchical update for #${number} (${isClosed ? 'closed' : 'reopened'})`);
              await propagateUpHierarchy([number], shouldCheck, 0);
            }

            // Only proceed to project status updates on close/reopen
            if (!(isClosed || isReopened)) {
              return;
            }

            // 2) Update project status of referenced issues
            const statusFieldName = process.env.STATUS_FIELD_NAME || 'Status';
            const doneOptionName = process.env.DONE_OPTION_NAME || 'Done';
            const reopenOptionName = process.env.REOPEN_OPTION_NAME || 'In Progress';
            const desiredOptionName = isClosed ? doneOptionName : reopenOptionName;

            const data = await github.graphql(`
              query($owner: String!, $repo: String!, $number: Int!) {
                repository(owner: $owner, name: $repo) {
                  issue(number: $number) {
                    id
                    projectItems(first: 50) {
                      nodes {
                        id
                        project {
                          ... on ProjectV2 { id title }
                        }
                      }
                    }
                  }
                }
              }
            `, { owner, repo, number });

            const items = data?.repository?.issue?.projectItems?.nodes || [];
            if (items.length === 0) {
              core.info('No project items to update.');
              return;
            }

            const itemsByProject = items.reduce((acc, it) => {
              const projectId = it.project?.id;
              if (!projectId) return acc;
              acc[projectId] = acc[projectId] || [];
              acc[projectId].push(it.id);
              return acc;
            }, {});

            for (const [projectId, itemIds] of Object.entries(itemsByProject)) {
              const proj = await github.graphql(`
                query($id: ID!) {
                  node(id: $id) {
                    ... on ProjectV2 {
                      id
                      title
                      fields(first: 50) {
                        nodes {
                          ... on ProjectV2SingleSelectField {
                            id
                            name
                            options { id name }
                          }
                        }
                      }
                    }
                  }
                }
              `, { id: projectId });

              const fields = proj?.node?.fields?.nodes || [];
              const statusField = fields.find(f => f?.name?.toLowerCase() === statusFieldName.toLowerCase());
              if (!statusField) {
                core.info(`Project ${proj?.node?.title || projectId} has no field "${statusFieldName}". Skipping.`);
                continue;
              }
              const option = statusField.options.find(o => o?.name?.toLowerCase() === desiredOptionName.toLowerCase());
              if (!option) {
                core.info(`Project ${proj?.node?.title || projectId} field "${statusFieldName}" has no option "${desiredOptionName}". Skipping.`);
                continue;
              }

              for (const itemId of itemIds) {
                try {
                  await github.graphql(`
                    mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: ID!) {
                      updateProjectV2ItemFieldValue(input: {
                        projectId: $projectId,
                        itemId: $itemId,
                        fieldId: $fieldId,
                        value: { singleSelectOptionId: $optionId }
                      }) {
                        clientMutationId
                      }
                    }
                  `, {
                    projectId,
                    itemId,
                    fieldId: statusField.id,
                    optionId: option.id,
                  });
                  core.info(`Updated project item ${itemId} -> ${desiredOptionName}`);
                } catch (e) {
                  core.warning(`Failed updating item ${itemId}: ${e.message}`);
                }
              }
            }
